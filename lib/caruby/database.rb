require 'generator'
require 'caruby/util/log'
require 'caruby/util/collection'
require 'caruby/util/validation'
require 'caruby/util/options'
require 'caruby/util/visitor'
require 'caruby/util/inflector'
require 'caruby/database/persistable'
require 'caruby/database/persistence_service'
require 'caruby/database/reader'
require 'caruby/database/writer'
require 'caruby/database/persistifier'

module CaRuby
  # The caBIG client session class.
  java_import Java::gov.nih.nci.system.comm.client.ClientSession
  
  # Database operation error.
  class DatabaseError < RuntimeError; end

  # A Database mediates access to a caBIG database. Database is a facade for caBIG application service
  # database operations. Database supports the query, create, update and delete operations supported by
  # the application service.
  #
  # Database strives to provide a simple WYEIWYG (What You Expect Is What You Get) API, consisting of
  # the following workhorse methods:
  # * {Query#query} - fetch domain objects which match a template
  # * {Store#find} - fetch a specific domain object by key
  # * {Store#store} - if a domain object exists in the database, then update it, otherwise create it
  #
  # Any domain object can serve as a query argument. If an optional attribute path is specified, then
  # that path is followed to the result, e.g.:
  #   database.query(study, :coordinator)
  # returns the coordinators of studies which match the +study+ template.
  #
  # A domain object find argument must contain enough data to determine whether it exists in the database,
  # i.e. the find argument has a database identifier or a complete secondary key.
  #
  # The {Store#store} method creates or updates references as necessary to persist its argument domain object.
  # It is not necessary to fetch references first or follow dependency ordering rules, which can be
  # implicit and tortuous in caBIG applications. Build the object you want to persist and call the
  # store method. CaRuby::Resource sets reasonable default values, recognizes application dependencies and steers
  # around caBIG idiosyncracies to the extent possible.
  class Database
    include Reader, Writer, Persistifier

    # Database CRUD operation.
    class Operation
      attr_reader :type, :subject, :attribute

      # @param [:find, :query, :create, :udate, :delete] type the database operation type
      # @param [Persistable] subject the domain object on which the operation is performed
      # @param [{Symbol => Object}, Symbol, nil] the operation characteristics
      # @option opts [Symbol] :attribute the query attribute
      # @option opts [Boolean] :autogenerated whether this is an auto-generated subject update
      def initialize(type, subject, opts=nil)
        @type = type
        @subject = subject
        @attribute = Options.get(:attribute, opts)
        @autogenerated = Options.get(:autogenerated, opts, false)
      end
      
      # @return [Boolean] whether this operation is an update of an auto-generated subject
      def autogenerated?
        @autogenerated
      end
      
      def to_s
        "#{@subject.qp} #{attribute} #{type}"
      end
    end
    
    attr_reader :operations
    
    # @return [PersistenceService] the services used by this database
    attr_reader :persistence_services

    # Creates a new Database with the specified service name and options.
    #
    # @quirk caCORE obtaining a caCORE session instance mysteriously depends on referencing the
    #   application service first. Therefore, the default persistence service appService method must
    #   be called after it is instantiated and before the session is instantiated. However, when
    #   the appService method is called just before a session is acquired, then this call corrupts
    #   the object state of existing objects.
    #
    #   Specifically, when a CaTissue::CollectionProtocol is created which references a
    #   CaTissue::CollectionProtocolRegistration which in turn references a CaTissue::Participant,
    #   then the call to PersistenceService.appService replaces the CaTissue::Participant
    #   reference with a difference CaTissue::Participant instance. The work-around for
    #   this extremely bizarre bug is to call appService immediately after instantiating
    #   the default persistence service.
    #
    #   This bug might be a low-level JRuby-Java-caCORE-Hibernate confusion where something in
    #   caCORE stomps on an existing JRuby object graph. To reproduce, move the appService call
    #   to the start_session method and run {PCBIN::MigrationTest#test_save} with all but the
    #   verify_save(:biopsy, BIOPSY_OPTS) line commented out.
    #
    # @param [String] service_name the name of the default {PersistenceService}
    # @param [{Symbol => String}] opts access options
    # @option opts [String] :host application service host name
    # @option opts [String] :login application service login user
    # @option opts [String] :password application service login password
    # @example
    #   Database.new(:user => 'perdita', :password => 'changeMe')
    def initialize(service_name, opts)
      super()
      # the fetched object cache
      @cache = create_cache
      @defaults = {}
      @user = Options.get(:user, opts)
      @password = Options.get(:password, opts)
      host = Options.get(:host, opts)
      port = Options.get(:port, opts)
      # class => service hash; default is the catissuecore app service
      @def_persist_svc = PersistenceService.new(service_name, :host => host, :port => port)
      @def_persist_svc.app_service
      @persistence_services = [@def_persist_svc].to_set
      @cls_svc_hash = Hash.new(@def_persist_svc)
      # the create/update nested operations
      @operations = []
      # the objects for which exists? is unsuccessful in the context of a nested operation
      @transients = Set.new
    end

    # Calls the block given to this method with this database as an argument, and closes the
    # database when done.
    #
    # @yield [database] the operation to perform on the database
    # @yieldparam [Database] database self
    def open
      # reset the execution timers
      persistence_services.each { |svc| svc.timer.reset }
      # call the block and close when done
      yield(self) ensure close
    end
    
    # Clears the cache.
    def clear
      @cache.clear
    end

    # Releases database resources. This method should be called when database interaction
    # is completed.
    def close
      return if @session.nil?
      begin
        @session.terminate_session
      rescue Exception => e
        logger.error("Session termination unsuccessful - #{e.message}")
      end
      # clear the cache
      clear
      logger.info("Disconnected from application server.")
      @session = nil
    end
    
    # @return [Numeric] the execution time in seconds spent since the last open
    def execution_time
      persistence_services.inject(0) do |total, svc|
        st = svc.timer.elapsed
        total + st
      end
    end

    # Returns the PersistanceService to use for the given domain object.
    # This base method always returns the standard application service.
    # Subclasses can override for specialized services. A session is
    # started on demand if necessary.
    #
    # @param [Persistable, Class] obj the domain object or {Resource} class
    # @return [PersistanceService] the service for the domain object
    def persistence_service(klass)
       unless Class === klass then raise ArgumentError.new("#{self} persistence_service argument is not a Class: {#klass.qp}") end
       start_session if @session.nil?
       @def_persist_svc
    end
    
    # Adds the given service to this database.
    #
    # @param [PersistenceService] service the service to add
    def add_persistence_service(service)
      @persistence_services << service
    end

    alias :to_s :print_class_and_id

    alias :inspect :to_s

    ## Utility classes and methods, used by Query and Store mix-ins ##

    private
    
    # A mergeable autogenerated operation is recursively defined as:
    # * a create of an object with auto-generated dependents
    # * an update of an auto-generated dependent in the context of a mergeable autogenerated operation
    #
    # @return whether the innermost operation conforms to the above criterion
    def mergeable_autogenerated_operation?
      # the inner operation subject
      inner = nil
      @operations.reverse_each do |op|
        if inner and op.subject != inner.owner then
          # not a dependent
          return false
        end
        if op.type == :create then
          # innermost or owner create
          return (not op.subject.class.autogenerated_dependent_attributes.empty?)
        elsif op.type != :update then
          # not a save
          return false
        end
        # iterate to the scoping operation
        inner = op.subject
      end
      false
    end
    
    # Performs the operation given by the given op symbol on obj by calling the block given to this method.
    # Lazy loading is suspended during the operation.
    #
    # @param [:find, :query, :create, :udate, :delete] op the database operation type
    # @param [Resource] obj the domain object on which the operation is performed
    # @param opts (#see Operation#initialize)
    # @yield the database operation block
    # @return the result of calling the operation block
    def perform(op, obj, opts=nil)
      op_s = op.to_s.capitalize_first
      attr = Options.get(:attribute, opts)
      attr_s = " #{attr}" if attr
      ag_s = " autogenerated" if Options.get(:autogenerated, opts)
      ctxt_s = " in context #{print_operations}" unless @operations.empty?
      logger.info(">> #{op_s}#{ag_s} #{obj.pp_s(:single_line)}#{attr_s}#{ctxt_s}...")
      @operations.push(Operation.new(op, obj, opts))
      begin
        # perform the operation
        result = @lazy_loader.suspend { yield }
      ensure
        # the operation is done
        @operations.pop
        # If this is a top-level operation, then clear the transient set.
        if @operations.empty? then @transients.clear end
      end
      logger.info("<< Completed #{obj.qp}#{attr_s} #{op}.")
      result
    end
    
    def each_persistence_service(&block)
      ObjectSpace.each_object(PersistenceService, &block)
    end
    
    # @return [Cache] a new object cache.
    def create_cache
      # @quirk JRuby identifier is not a stable object when fetched from the database, i.e.:
      #     obj.identifier.equal?(obj.identifier) #=> false
      #   This is probably an artifact of jRuby Numeric - Java Long conversion interaction
      #   combined with hash access use of the eql? method. Work-around is to make a Ruby Integer.
      Cache.new do |obj|
        raise ArgumentError.new("Can't cache object without identifier: #{obj}") unless obj.identifier
        obj.identifier.to_s.to_i
      end
    end
    
    # Initializes the default application service.
    def start_session
      if @user.nil? then raise DatabaseError.new('Application user option missing') end
      if @password.nil? then raise DatabaseError.new('Application password option missing') end
      @session = ClientSession.instance
      connect(@user, @password)
    end

    # Returns the current database operation stack as a String.
    def print_operations
      ops = @operations.reverse.map do |op|
        attr_s = " #{op.attribute}" if op.attribute
        "#{op.type.to_s.capitalize_first} #{op.subject.qp}#{attr_s}"
      end
      ops.qp
    end

    # Connects to the database.
    def connect(user, password)
      logger.debug { "Connecting to application server with login id #{user}..." }
      begin
        @session.start_session(user, password)
      rescue Exception => e
        logger.error("Login of #{user} unsuccessful - #{e.message}") and raise
      end
      logger.info("Connected to application server.")
    end
  end
end